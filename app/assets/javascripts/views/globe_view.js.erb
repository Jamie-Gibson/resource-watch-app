(function(App) {

  'use strict';

  App.View.Globe = App.Core.View.extend({

    tagName: 'div',

    className: 'globe',

    props: {
      perspective: 45,
      maxRadius: 1000,
      minRadius: 1,
      initialRadius: 1,
      segments: 32,
      renderer: { antialias: true, alpha: true },
      cameraPosition: { z: 3 }
    },

    defaults: {
      baseLayer: {
        slug:'clouds',
        link: '<%= asset_path("planet_pulse/fair_clouds_4k.png") %>'
      }
    },

    initialize: function(settings) {
      this.currentLayer = settings.layer || this.defaults.baseLayer;
      this.data = new App.Model.PlanetLayer();
      this._createScene();
      this._addAmbientLight();
      this.draw();
    },

    /**
     * Creating Three js scene
     * http://threejs.org/docs/index.html
     */
    _createScene: function() {
      this.size = App.helpers.calcSize(this.el);
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(
        this.props.perspective,
        this.size.width / this.size.height,
        this.props.minRadius,
        this.props.maxRadius
      );
      this.controls = new THREE.OrbitControls(this.camera);
      this.renderer = new THREE.WebGLRenderer(this.props.renderer);

      // Initial settings
      this.controls.minDistance = 2;
      this.controls.maxDistance = 10;
      this.camera.position.z = this.props.cameraPosition.z;
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.setSize(this.size.width, this.size.height);
    },

    /**
     * An ambient light
     */
    _addAmbientLight: function() {
      var light = new THREE.HemisphereLight( 0xffffff, 0x080808, 1 );
      var ambientLight = new THREE.AmbientLight(0x444444);

      light.position.set(-10, 3, 5);
      this.scene.add(light);
      this.scene.add(ambientLight);
    },

    /**
     * Draw all the elements in canvas
     */
    draw: function() {
      var _this = this;

      this.el.appendChild(this.renderer.domElement);

      var animate = function() {
        requestAnimationFrame(animate);
        // _this.earth.rotation.y += 0.0005;
        // if (_this.layer) {
        //   _this.layer.rotation.y += 0.0005;
        // }
        _this.controls.update();
        _this.renderer.render(_this.scene, _this.camera);
      };

      $.when(
        this.createStars(),
        this.createEarth(),
        this.setLayer(this.currentLayer)
      ).done(animate);
    },

    /**
     * Update current layer
     */
    render: function() {},

    /**
     * Update current layer
     */
    updateLayer: function(newLayer, options) {
      newLayer = newLayer || this.defaults.baseLayer;
      if (this.currentLayer.slug!==newLayer.slug) {
        this.currentLayer = newLayer;
        this.removeLayer();
        this.setLayer(newLayer, options);
      }
    },

    /**
     * Setting planet layer from API
     */
    setLayer: function(currentLayer, options) {
      var deferred = new $.Deferred();
      var _this = this;
      var radius = this.props.initialRadius;
      var radiusDistance = currentLayer.slug === this.defaults.baseLayer.slug? 0.003:0.001;
      var segments = this.props.segments;
      var settings = options || {};

      _this._loadTexture(currentLayer.link)
      .done(function(texture) {
        var geometry = new THREE.SphereGeometry(radius + radiusDistance, segments, segments);
        var material = new THREE.MeshBasicMaterial({
          map: texture,
          side: THREE.DoubleSide,
          transparent: true
        });
        material.opacity = settings.opacity || 0.5;
        _this.layer = new THREE.Mesh(geometry, material);
        _this.scene.add(_this.layer);
        deferred.resolve(_this.layer);
      });
      return deferred.promise();
    },

    /**
     * Method to remove current layer
     */
    removeLayer: function() {
      if (this.layer) {
        this.scene.remove(this.layer);
      }
    },

    /**
     * Create stars in background
     * @return {[type]} [description]
     */
    createStars: function() {
      var deferred = new $.Deferred();
      var radius = this.props.maxRadius;
      var segments = this.props.segments;
      var scene = this.scene;

      this._loadTexture('<%= asset_path("planet_pulse/galaxy_starfield_4k.png") %>')
        .done(function(texture) {
          var geometry = new THREE.SphereGeometry(radius, segments, segments);
          var material = new THREE.MeshBasicMaterial({
            map: texture,
            side: THREE.BackSide
          });
          this.stars = new THREE.Mesh(geometry, material);
          this.scene.add(this.stars);
          deferred.resolve(this.stars);
        }.bind(this));
      return deferred.promise();
    },

    /**
     * Create earth
     */
    createEarth: function() {
      var deferred = new $.Deferred();
      var scene = this.scene;
      var radius = this.props.initialRadius;
      var segments = this.props.segments;
      var geometry = new THREE.SphereGeometry(radius, segments, segments);

      $.when(
        this._loadTexture('<%= asset_path("planet_pulse/earth_no_clouds_4k.jpg") %>'),
        this._loadTexture('<%= asset_path("planet_pulse/elev_bump_4k.jpg") %>'),
        this._loadTexture('<%= asset_path("planet_pulse/water_4k.png") %>')
      ).done(function(basemapTexture, bumpTexture, specularTexture) {
          var geometry = new THREE.SphereGeometry(radius, segments, segments);
          var material = new THREE.MeshPhongMaterial({
            map: basemapTexture,
            bumpMap: bumpTexture,
            bumpScale: 0.001,
            specularMap: specularTexture,
            specular: new THREE.Color('grey')
          });
          this.earth = new THREE.Mesh(geometry, material);
          this.scene.add(this.earth);
          deferred.resolve(this.earth);
        }.bind(this));

      return deferred.promise();
    },

    /**
     * A promise to load textures
     * @param  {String} texturePath
     * @return {Promise}
     */
    _loadTexture: function(texturePath) {
      var deferred = new $.Deferred();
      var loader = new THREE.TextureLoader();
      loader.setCrossOrigin('*');
      loader.load(
        texturePath,
        function(texture) {
          deferred.resolve(texture);
        }, // Success
        function(xhr) {
          console.log( (xhr.loaded / xhr.total * 100) + '% loaded' )
        },
        function() { console.log('And error happened') }
      );
      return deferred.promise();
    }

  });

}).call(this, this.App);
